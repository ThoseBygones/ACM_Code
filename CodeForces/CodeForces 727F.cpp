#include <iostream>
#include <algorithm>
#define LL long long
using namespace std;

//这题我们要求什么？求的是去掉问题个数j的最小值！我们可以开一个二维数组dp[i][j]，遍历j(0~n)来求出符合要求的最小j值
//dp数组存的是什么？从第n个到第1个，去掉j个问题，连续和中最小值的最大的那个。即去掉的天数最小，然后这个连续和要尽量大！

int a[755];
LL dp[755][755];
int n,m;

int main()
{
    cin >> n >> m;
    for(int i=1; i<=n; i++)
        cin >> a[i];
    dp[n+1][0]=0;   //从dp[n+1]开始，让它作为起始点来反向推
    for(int i=n; i>=1; i--) //反向推，假设给定你一个mood，也就是dp[n+1][j]，你要遍历找到能使全过程中mood>=0且j最小的方案
    {
        for(int j=0; j<=n; j++) //j为要去掉的问题数量，从0~n遍历
        {
            dp[i][j]=min(dp[i+1][j]+a[i],(LL)0);    //若a[i]为负，或者a[i]+dp[i+1]仍为负，则我们把它特别标记，这个a[i]可能我们最后要去掉
            if(j>0)
                dp[i][j]=max(dp[i][j],dp[i+1][j-1]);    //j如果为零，就是不去掉，那就不需要做什么操作；否则要比较，去掉问题个数少1的情况下，是不是也有能满足要求的解呢？
        }
    }
    while(m--)
    {
        LL x;   ///!!!这里没用LL，让我WA了好几次！！！，因为测试数据范围是1-10^15！！！
        cin >> x;
        cout << lower_bound(dp[1],dp[1]+n+1,-x)-dp[1] << endl;  //二分法求值的函数：三个参数分别为（指向第一个元素的迭代器，指向最后一个元素的迭代器，你要查找的那个元素的值）
        //这里取-x的原因是前面dp的时候a[i]使用是用+的，因此，这里要用负的；求得位置后要-dp[i]是因为我们要求的是j的最小值，而用lower_bound二分查到了dp[i][j]的相对地址以后要减去dp[i][0]的地址，相当于求的是j的下标，即j的值！！！
    }
    return 0;
}
